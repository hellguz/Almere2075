<./.gitignore>
.gpt/*.txt
*/.env
*/
................................

<./docker-compose.yml>
# docker-compose.yml

version: '3.8'

services:
  nginx:
    image: nginx:alpine
    container_name: almere-proxy
    restart: unless-stopped
    ports:
      # Expose standard HTTP port 80 to the host.
      # Your server will route traffic from your domain to this port.
      - "2075:80"
    volumes:
      # FIX: Mount the config file to the correct directory where server blocks are expected,
      # overwriting the default Nginx server configuration.
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf
    depends_on:
      - backend
      - frontend
    networks:
      - almere-net

  backend:
    build: ./backend
    container_name: almere-backend
    restart: unless-stopped
    env_file:
      - ./backend/.env
    # Ports are no longer exposed to the host, only to the nginx proxy
    expose:
      - "3000"
    volumes:
      - ./backend:/usr/src/app
      - /usr/src/app/node_modules
    command: npm run dev
    networks:
      - almere-net

  frontend:
    build: ./frontend
    container_name: almere-frontend
    restart: unless-stopped
    # Ports are no longer exposed to the host, only to the nginx proxy
    expose:
      - "5173"
    depends_on:
      - backend
    volumes:
      - ./frontend:/usr/src/app
      - /usr/src/app/node_modules
    networks:
      - almere-net

networks:
  almere-net:
    driver: bridge

<./README.md>
# Almere2075

<./backend\.env>
OPENAI_API_KEY="OPENAI_API_KEY_REDACTED"
REPLICATE_API_KEY="REPLICATE_API_KEY_REDACTED"

<./backend\Dockerfile>
# backend/Dockerfile

# Use an official Node.js runtime as a parent image
FROM node:18-alpine

# Install system dependencies required by the 'sharp' library for image processing
RUN apk add --no-cache vips-dev build-base

# Set the working directory in the container
WORKDIR /usr/src/app

# Copy package.json and package-lock.json (if available)
COPY package.json ./

# Install app dependencies
RUN npm install

# Bundle app source
COPY . .

# Your app binds to port 3000
EXPOSE 3000

# Define the command to run your app
CMD [ "npm", "start" ]



<./backend\package.json>
{
  "name": "almere-
................................

<./backend\server.js>
const express = require("express");
const fetch = require("node-fetch");
const cors = require("cors");
const Replicate = require("replicate");
require("dotenv").config();
const fs = require("fs").promises;
const path = require("path");
const sharp = require("sharp");

const app = express();
const PORT = process.env.PORT || 3000;

// --- Image Processing Setup ---
const IMAGES_DIR = path.join(__dirname, "images");
const THUMBNAILS_DIR = path.join(__dirname, "thumbnails");
const THUMBNAIL_WIDTH = 240; // width in pixels

// Function to generate thumbnails
const generateThumbnails = async () => {
  try {
    await fs.mkdir(THUMBNAILS_DIR, { recursive: true });
    console.log("LOG: Thumbnails directory is ready.");
    const files = await fs.readdir(IMAGES_DIR);
    console.log(`LOG: Found ${files.length} items in images directory.`);

    for (const file of files) {
      const imagePath = path.join(IMAGES_DIR, file);
      const thumbPath = path.join(THUMBNAILS_DIR, file);

      try {
        await fs.access(thumbPath); // Check if thumbnail already exists
      } catch {
        // If it doesn't exist, create it
        await sharp(imagePath)
          .resize(THUMBNAIL_WIDTH)
          .toFile(thumbPath);
        console.log(`LOG: Generated thumbnail for ${file}`);
      }
    }
  } catch (error) {
    console.error("LOG: Error generating thumbnails:", error);
    // If the images directory doesn't exist, we can ignore it.
    if (error.code !== 'ENOENT') {
      throw error;
    } else {
        console.warn("LOG: 'images' directory not found. Skipping thumbnail generation.");
    }
  }
};


// FIX: Stricter CORS policy for production
const allowedOrigins = [
  "http://localhost:2075",
  "http://127.0.0.1:2075",
  "https://almere.i-am-hellguz.uk",
];

const corsOptions = {
  origin: (origin, callback) => {
    // Allow requests with no origin (like mobile apps or curl requests)
    if (!origin) return callback(null, true);
    if (allowedOrigins.indexOf(origin) === -1) {
      const msg =
        "The CORS policy for this site does not " +
        "allow access from the specified Origin.";
      return callback(new Error(msg), false);
    }
    return callback(null, true);
  },
};
app.use(cors(corsOptions));
app.use(express.json({ limit: "10mb" }));
const replicate = new Replicate({
  auth: process.env.REPLICATE_API_KEY,
});

const systemPromptForFlux = `

You are the "Almere 2075 Cinematic Architect."
Your mission is to function as a visionary concept artist, creating ONE exceptionally detailed, evocative, and ambitious prompt for the FLUX.1 Kontext model.
You will transform a contemporary photo into a compelling, photorealistic scene that showcases the beautiful, modern, and sustainable future envisioned in the Almere 2075 student projects, based on their core concepts.
Your focus is on creating a single, stunning frame that tells a rich story about life in this new city.
**Core Mandates & Preservation Rules**

* **Output Format:** Your entire response MUST consist of exactly ONE creative prompt.
Do not output ANY other text, preamble, or explanation.
* **Preserve the Scene's Core:** You must meticulously maintain the original photo's:
    * Camera Position & Angle.
    * Time of Day, Weather, and Lighting.
* **Existing People:** Do not remove or change any of the original people in the photo.
**Core Philosophy: Your Guiding Principles**

* **Create a Lively Architectural Photograph:** Your target style is high-end architectural photography, full of life.
It must look like a real, professionally captured photograph, not a sterile render.
Use descriptive language to achieve this: "captured with a high-detail professional camera," "crisp focus," "natural and realistic lighting," "rich textures of materials like timber and stone."
* **Tell a Story with New People:** You should add one or two new, acting people to the scene to make it feel alive.
Describe their specific, playful, or interesting actions that connect them to the new futuristic elements and tell a story.
* **The Green Imperative:** Every prompt you generate MUST feature significant and visible green/living infrastructure from the Concept Palette.
Almere in 2075 is fundamentally a green city.
* **Visualize the Threat:** The prompt shouldn't just show the solution;
it must subtly visualize the reason for it. If the solution is an "Amphibious Building," the prompt should describe the ground as a "shallow canal for water transport" or "glistening with recent rainwater from a storm," clearly connecting the architecture to threats like floods and intense rain.
* **Context is King:** You MUST analyze the input image's context (e.g., dense street, residential hill) and choose an architectural typology from the Palette that is appropriate.
Do not default to the same solution for every prompt. Show architectural variety.
**The Core Transformation Rule (The Key to Recognizability)**

* **Surgical Replacement & Preservation:** Your primary architectural instruction is to surgically replace one or two key buildings with new, modern structures, while explicitly preserving the surrounding context to maintain recognizability.
* **Replace by Volume:** The new building MUST strictly follow the original building's volumetric form (its 3D footprint, height, and overall massing).
The architectural style will be completely new, but it will occupy the exact same space as the old, anchoring the scene.
* **Transform the Ground:** You must always describe the complete transformation of the ground plane (the street, sidewalk, or square) using a concept from the palette that reflects the environmental threat (e.g., a Sponge Park to absorb rain, a canal to manage flooding).
**Almere 2075 Concept Palette (Based on Student Concepts)**

* **Architectural Typologies:**
    * Kinetic Timber & Glass Residences: Buildings with heavy timber exoskeletons, floor-to-ceiling windows, and flat, green roofs.
    * Modular Pod Housing: Buildings composed of visible, interlocking prefabricated modules with shared terraces.
    * Amphibious/Plinth Buildings: Structures with open, flood-proof ground floors used for boat access or as open community space.
    * Community Repair Hubs: Buildings with open-plan, visible ground-floor workshops.
    * Biocycle Hubs: Workshops producing new goods from recycled waste (e.g., plastic, metal).
    * Vertical Farm Towers: Dedicated, multi-story structures for hydroponic food production.
* **Green & Living Infrastructure:**
    * Sponge Parks: Absorbent landscapes of native grasses and bioswales replacing pavement.
    * Rooftop Greenhouses: Visible glass structures and lush gardens on top of new buildings.
    * Edible Streetscapes: Public walkways lined with planters for fruits and vegetables.
    * Cascading Water Features: Waterfalls and channels integrated into terraced landscapes.
    * Flood-Adaptive Plazas: Public squares designed to hold or channel water during floods.
    * Sky-Park Farms: Agricultural parks integrated into rooftops and building terraces.
* **Technology & Narrative Elements:**
    * Elevated Mobility Systems: Suspended walkways and bicycle paths made of translucent composites.
    * Autonomous Delivery Drones & Robotic Assistants: Small, sleek machines performing tasks.
    * Autonomous Water Transport: Canals with docked, electric water buses and pods.
    * Integrated Greywater Filtration: Visible pipes and systems showing water being cleaned and reused.
    * Urban Mining: Visible processes of carefully dismantling old structures for new materials.
    * Floating Classrooms or Clinics: Modular service pods that can function on water.
---
**PERFECT PROMPT EXAMPLES (Follow this style and level of detail):**

**Example 1:** "Replace the red-brick building with a 'Modular Pod Housing' structure that perfectly matches the original's volume and hip-roof form. The new building is visibly composed of interlocking modules of heavy timber and light-colored recycled composites, with some pods extended as balconies overflowing with plants. The roof is now a shared 'Rooftop Greenhouse,' its glass structure glowing warmly. The street and parking lot are replaced by a calm canal for 'Autonomous Water Transport,' with the sidewalk transformed into a wooden boardwalk featuring an 'Edible Streetscape' of integrated planters. Add a new person, an elderly resident, tending to the herbs in a planter on the boardwalk as a sleek, autonomous water taxi silently docks nearby. The style is a professional architectural photograph, capturing the warm textures of the timber against the cool, reflective water under the same overcast sky, preserving the yellow building on the left."
**Example 2:** "Replace the pink building on the right with a new 'Modular Pod Housing' structure that strictly follows its original volumetric form and gabled roofline. The new facade is composed of interlocking modules made of light-colored recycled composites, each with a large window and a small timber balcony overflowing with flowering plants. The entire cobblestone square is transformed into a 'Sponge Park,' a lush landscape of soft mosses and native grasses with a shallow, clean stream meandering through it. Add a young parent and a child at the edge of the stream; the child is laughing while placing a small, glowing toy boat in the water. while preserving the building on the left, the clock tower, all original people in the background, and the bright daytime lighting. The style is a crisp, lively, and high-detail architectural photograph, full of warm sunlight."
**Example 3:** "Replace the row of buildings on the left with new 'Kinetic Timber & Glass Residences' that strictly follow the original volumetric form and rooflines. The new structures feature a heavy timber exoskeleton, floor-to-ceiling windows, and balconies overflowing with lush greenery. The entire cobblestone street and sidewalk are transformed into a 'Sponge Park,' a continuous landscape of soft native grasses, mosses, and shallow bioswales collecting rainwater, with a central winding path made of permeable pavers. Add a new person, an urban botanist, kneeling to inspect the plant life in a bioswale. The style is a crisp, high-detail architectural photograph, captured with a professional camera under the same overcast sky, highlighting the rich textures of the wood and the soft, absorbent park landscape, while preserving the original half-timbered building on the right and the people sitting at the cafe."
**Example 4:** "Replace all the buildings visible through the archway with 'Kinetic Timber & Glass Residences' that strictly adhere to the original volumetric forms and rooflines of the historic structures. The new buildings feature heavy timber exoskeletons, floor-to-ceiling windows, and balconies overflowing with cascading greenery. The inclined cobblestone street is transformed into a 'Cascading Water Feature,' a series of shallow, clear water terraces and miniature waterfalls flowing gently down the slope, bordered by wide steps made of recycled stone. Add a new child sitting on the steps, safely splashing their hands in the sparkling water. The style is a high-detail architectural photograph, perfectly preserving the old stone archway in the foreground to create a frame, while capturing the rich textures of the new timber and the lively, sunlit water beyond, all while keeping the original pedestrians in the scene."
**Example 5:** "Replace the yellow brick building on the left with a 'Community Repair Hub' that matches the original's volume, featuring a large, open glass garage door revealing a brightly lit workshop. The building on the right is transformed into a 'Kinetic Timber & Glass Residence' of the same shape. The entire cobblestone courtyard, including the parked van, is replaced by a miniature 'Edible Streetscape,' a community garden with raised planters made of recycled plastic, filled with herbs and vegetables. Add a new resident from the timber building kneeling to tend to a planter, while inside the workshop, another person is visibly repairing an e-bike. The style is a lively, high-detail architectural photograph, preserving the tree branches at the top left and the overcast sky, capturing the rich textures of the garden and the tools in the workshop."
`;

// --- API Endpoints ---

// LOG: Add a logging middleware for all /api requests
app.use("/api", (req, res, next) => {
  console.log(`LOG: Received API request: ${req.method} ${req.originalUrl}`);
  next();
});

// Serve static files from the thumbnails and images directories
app.use("/api/thumbnails", express.static(THUMBNAILS_DIR));
app.use("/api/images", express.static(IMAGES_DIR));

// Endpoint to get the list of available images
app.get("/api/images", async (req, res) => {
  try {
    console.log("LOG: Endpoint /api/images hit.");
    const files = await fs.readdir(IMAGES_DIR);
    const imageFiles = files.filter((file) =>
      /\.(jpg|jpeg|png|webp)$/i.test(file)
    );
    console.log(`LOG: Found ${imageFiles.length} valid images. Sending list.`);
    res.json(imageFiles);
  } catch (error) {
    console.error("LOG: ERROR in /api/images endpoint:", error);
    if (error.code === 'ENOENT') {
      return res.json([]); // Return empty array if directory doesn't exist
    }
    res.status(500).json({ error: "Could not list image directory." });
  }
});


// FIX: The route path must now include /api
app.post("/api/generate-prompt", async (req, res) => {
  const { imageBase64 } = req.body;
  if (!imageBase64)
    return res.status(400).json({ error: "Image data is required." });

  try {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
      },
      body: JSON.stringify({
        model: "gpt-4-turbo",
        messages: [
          { role: "system", content: systemPromptForFlux },
          {
            role: "user",
            content: [
              {
                type: "text",
                text: "Generate a prompt for the following image:",
              },
              { type: "image_url", image_url: { url: imageBase64 } },
            ],
          },
        ],
        max_tokens: 300,
      }),
    });

    if (!response.ok) {
      const err = await response.json();
      throw new Error(err.error.message);
    }
    const data = await response.json();

    let promptContent = data.choices[0].message.content;
    try {
      const parsed = JSON.parse(promptContent);
      if (parsed && parsed.prompt) {
        promptContent = parsed.prompt;
      }
    } catch (e) {
      // It's not a JSON string, so we use it as is.
    }
    promptContent = promptContent.replace(/\*\*/g, "");

    res.json({ prompt: promptContent });
  } catch (error) {
    res.status(500).json({ error: `OpenAI Error: ${error.message}` });
  }
});

// FIX: The route path must now include /api
app.post("/api/transform-image", async (req, res) => {
  const { imageBase64, prompt } = req.body;
  if (!imageBase64 || !prompt)
    return res.status(400).json({ error: "Image and prompt are required." });

  try {
    const modelVersion = "black-forest-labs/flux-kontext-pro";
    const output = await replicate.run(modelVersion, {
      input: {
        prompt: prompt,
        input_image: imageBase64,
      },
    });

    console.log("--- Received output from Replicate ---");
    console.log(output);
    console.log("------------------------------------");

    let imageUrl = null;
    if (Array.isArray(output) && output.length > 0) {
      imageUrl = output[0];
    } else if (typeof output === "string") {
      imageUrl = output;
    }

    if (typeof imageUrl !== "string" || !imageUrl.startsWith("http")) {
      throw new Error(
        `Model returned an invalid output. Expected a URL string, but got: ${imageUrl}`
      );
    }

    res.json({ transformedImageUrl: imageUrl });
  } catch (error) {
    console.error("--- DETAILED REPLICATE ERROR ---");
    console.error(error);
    console.error("--------------------------------");
    res.status(500).json({ error: `Replicate Error: ${error.message}` });
  }
});

// Generate thumbnails on server start, then start listening
generateThumbnails().then(() => {
    app.listen(PORT, () =>
        console.log(`Server is running on http://localhost:${PORT}`)
    );
});

&&& FILE: ./backend\images\1741019704415_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0x9f in position 24: invalid start byte

&&& FILE: ./backend\images\1751030327225_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xb0 in position 4: invalid start byte

&&& FILE: ./backend\images\6f6f7f42-9da6-4f65-8852-d7b7e24dd4d0.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xe3 in position 5: invalid continuation byte

&&& FILE: ./backend\images\bibliothek_abend_web_02.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\c30a90ec-a8d6-4b98-aba4-ffe1d15b7dc8.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0x9f in position 27: invalid start byte

&&& FILE: ./backend\images\IMG20240323140913_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0x9f in position 24: invalid start byte

&&& FILE: ./backend\images\IMG20240711193321.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\IMG20241013130348_preview.jpeg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\IMG20241019153003_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xca in position 4: invalid continuation byte

&&& FILE: ./backend\images\IMG_20181028_100647_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xd8 in position 4: invalid continuation byte

&&& FILE: ./backend\images\IMG_20210204_121813_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0x86 in position 4: invalid start byte

&&& FILE: ./backend\images\IMG_20250609_214129324_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0x94 in position 5: invalid start byte

&&& FILE: ./backend\images\IMG_20250613_185645377_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xc0 in position 4: invalid start byte

&&& FILE: ./backend\images\IMG_20250616_211613360.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\IMG_20250617_100802744.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\IMG_20250620_192838949.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\IMG_20250627_112544347_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0x86 in position 4: invalid start byte

&&& FILE: ./backend\images\IMG_20250627_192200934_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0x9f in position 27: invalid start byte

&&& FILE: ./backend\images\IMG_20250627_192317603_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0x9f in position 27: invalid start byte

&&& FILE: ./backend\images\IMG_20250628_213414260.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\IMG_20250628_213841301.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\IMG_20250628_214141039.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\IMG_20250628_214149710.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\IMG_20250628_214313734.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\IMG_20250628_214549783.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\IMG_20250628_214753890.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\IMG_20250628_215026745.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\images\istockphoto-2094471351-612x612.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\1741019704415_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xbc in position 21: invalid start byte

&&& FILE: ./backend\thumbnails\1751030327225_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xfa in position 16: invalid start byte

&&& FILE: ./backend\thumbnails\6f6f7f42-9da6-4f65-8852-d7b7e24dd4d0.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xd8 in position 4: invalid continuation byte

&&& FILE: ./backend\thumbnails\bibliothek_abend_web_02.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\c30a90ec-a8d6-4b98-aba4-ffe1d15b7dc8.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xb0 in position 4: invalid start byte

&&& FILE: ./backend\thumbnails\IMG20240323140913_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0x8e in position 4: invalid start byte

&&& FILE: ./backend\thumbnails\IMG20240711193321.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\IMG20241013130348_preview.jpeg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\IMG20241019153003_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xda in position 4: invalid continuation byte

&&& FILE: ./backend\thumbnails\IMG_20181028_100647_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xb4 in position 4: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20210204_121813_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xb0 in position 20: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250609_214129324_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xf2 in position 4: invalid continuation byte

&&& FILE: ./backend\thumbnails\IMG_20250613_185645377_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0x90 in position 4: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250616_211613360.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250617_100802744.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250620_192838949.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250627_112544347_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xa2 in position 4: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250627_192200934_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0x80 in position 4: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250627_192317603_preview.webp
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xc8 in position 4: invalid continuation byte

&&& FILE: ./backend\thumbnails\IMG_20250628_213414260.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250628_213841301.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250628_214141039.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250628_214149710.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250628_214313734.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250628_214549783.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250628_214753890.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\IMG_20250628_215026745.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

&&& FILE: ./backend\thumbnails\istockphoto-2094471351-612x612.jpg
&&& ERROR: Could not read file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

<./frontend\.env>
# The backend URL is now a relative path to the API endpoint.
# Nginx will handle routing this to the correct service.
VITE_BACKEND_URL=/api



<./frontend\Dockerfile>
# frontend/Dockerfile

FROM node:18-alpine

WORKDIR /usr/src/app

# Copy package.json and install dependencies
COPY package.json .
RUN npm install

# Copy the rest of the frontend source code
COPY . .

# Expose Vite's default port
EXPOSE 5173

# Run the Vite development server
# The --host flag is crucial for making it accessible outside the container
CMD ["npm", "run", "dev", "--", "--host"]

<./frontend\index.html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Almere 2075 Cinematic Architect</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="main-container">
        <header class="header">
            <h1>Almere 2075</h1>
            <p>Transform a photo into a vision of a sustainable future.</p>
        </header>

        <div class="example-gallery-container">
            <h3>Click an example to start</h3>
            <div class="gallery-thumbnails">
                </div>
        </div>

        <main class="content">
            <div class="image-comparison-container">
                <div class="card image-card" id="original-card">
                    <div class="card-header">Original Image</div>
                    <div class="image-content-wrapper">
                        <div class="image-placeholder" id="original-image-placeholder">
                            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>
                            <span>Click to upload image</span>
                        </div>
                        <img id="original-image" alt="Original" style="display: none;">
                    </div>
                </div>
                <div class="card image-card" id="transformed-card">
                    <div class="card-header">Transformed Image</div>
                    <div class="image-content-wrapper">
                        <div class="image-placeholder" id="transformed-image-placeholder">
                           <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10A10 10 0 0 0 12 2Z"/><path d="m16.24 7.76-1.82 1.82a4 4 0 0 0-5.66 5.66l1.82 1.82"/><path d="m7.76 16.24 1.82-1.82a4 4 0 0 0 5.66-5.66l-1.82-1.82"/></svg>
                            <span>Awaiting transformation</span>
                        </div>
                        <div class="loader-container" id="loader">
                            <div class="loader"></div>
                             <p>Transforming image...</p>
                        </div>
                        <img id="transformed-image" alt="Transformed" style="display: none;">
                    </div>
                 </div>
            </div>

            <div class="prompt-container card">
                 <div class="card-header">Generated Prompt</div>
                 <p id="generated-prompt">The generated prompt will appear here once the transformation begins.</p>
            </div>
              <div class="controls-container">
                <input type="file" id="image-upload" accept="image/*" style="display: none;">
                <button class="button" id="upload-button">Upload Image</button>
                <button class="button" id="generate-button" disabled>Generate Transformation</button>
            </div>
        </main>
    </div>
    
    <script type="module" src="/script.js"></script>
</body>
</html>



<./frontend\nginx.conf>
# frontend/nginx.conf

server {
    listen 80;
    server_name localhost;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }
}

<./frontend\package.json>
{
  "name": "almere-
................................

<./frontend\script.js>
// frontend/script.js (Corrected)

document.addEventListener("DOMContentLoaded", () => {
  const imageUpload = document.getElementById("image-upload");
  const uploadButton = document.getElementById("upload-button");
  const generateButton = document.getElementById("generate-button");

  const originalImage = document.getElementById("original-image");
  const originalImagePlaceholder = document.getElementById(
    "original-image-placeholder"
  );

  const transformedImage = document.getElementById("transformed-image");
  const transformedImagePlaceholder = document.getElementById(
    "transformed-image-placeholder"
  );

  const generatedPrompt = document.getElementById("generated-prompt");
  const loader = document.getElementById("loader");
  const galleryContainer = document.querySelector(".gallery-thumbnails");

  // FIX: Add check for the environment variable to provide a clear error message.
  const BACKEND_URL = import.meta.env.VITE_BACKEND_URL;
  if (!BACKEND_URL) {
      const errorMsg = "CRITICAL ERROR: VITE_BACKEND_URL is not set. The application cannot contact the backend. Please check that the frontend/.env file exists and is correct.";
      console.error(errorMsg);
      // Display error directly on the page so it's impossible to miss.
      galleryContainer.innerHTML = `<p style="color: red; font-weight: bold; text-align: center;">${errorMsg}</p>`;
      return; // Stop execution
  }

  let uploadedImageBase64 = null;

  uploadButton.addEventListener("click", () => imageUpload.click());
  originalImagePlaceholder.addEventListener("click", () =>
    imageUpload.click()
  );
  imageUpload.addEventListener("change", handleImageUpload);
  generateButton.addEventListener("click", handleGeneration);
  galleryContainer.addEventListener("click", handleExampleImageClick);

  // Load gallery from the new backend endpoint
  populateExampleGallery();

  function handleImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      displayOriginalImage(e.target.result);
    };
    reader.readAsDataURL(file);
  }

  async function handleExampleImageClick(event) {
    const thumbnail = event.target;
    if (thumbnail.classList.contains("thumbnail")) {
      // Get the full-size image URL from the data attribute
      const imageUrl = thumbnail.dataset.fullImageUrl;
      if (!imageUrl) return;

      try {
        // To show loading state while fetching the example
        originalImage.style.display = "none";
        originalImagePlaceholder.style.display = "flex";
        originalImagePlaceholder.querySelector("span").textContent =
          "Loading example...";
        generateButton.disabled = true;
        const base64Data = await loadImageAsBase64(imageUrl);
        displayOriginalImage(base64Data);
      } catch (error) {
        console.error("Failed to load example image:", error);
        alert("Could not load the example image.");
        originalImagePlaceholder.querySelector("span").textContent =
          "Click to upload image";
      }
    }
  }

  async function loadImageAsBase64(url) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch image: ${response.statusText}`);
    }
    const blob = await response.blob();
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  function displayOriginalImage(base64Data) {
    // Reset state
    transformedImage.style.display = "none";
    transformedImage.src = "";
    transformedImagePlaceholder.style.display = "flex";
    generatedPrompt.textContent =
      "The generated prompt will appear here once the transformation begins.";
    // Set new image
    uploadedImageBase64 = base64Data;
    originalImage.src = uploadedImageBase64;
    originalImage.style.display = "block";
    originalImagePlaceholder.style.display = "none";
    generateButton.disabled = false;
  }

  async function handleGeneration() {
    if (!uploadedImageBase64) {
      alert("Please upload an image first.");
      return;
    }
    setLoading(true);
    try {
      generatedPrompt.textContent = "Generating prompt with AI...";
      const { prompt } = await fetchFromBackend("/generate-prompt", {
        imageBase64: uploadedImageBase64,
      });
      generatedPrompt.textContent = prompt;
      const refusalKeywords = [
        "sorry",
        "can't process",
        "unable to",
        "could not be processed",
      ];
      if (
        refusalKeywords.some((keyword) => prompt.toLowerCase().includes(keyword))
      ) {
        console.log("AI refused to process the image. Halting process.");
        transformedImagePlaceholder.style.display = "flex";
        setLoading(false);
        return;
      }

      const { transformedImageUrl } = await fetchFromBackend(
        "/transform-image",
        { imageBase64: uploadedImageBase64, prompt }
      );
      console.log("Received image URL from backend:", transformedImageUrl);

      if (transformedImageUrl) {
        transformedImage.src = transformedImageUrl;
        transformedImage.style.display = "block";
        transformedImagePlaceholder.style.display = "none";
      } else {
        throw new Error("Backend did not return a valid image URL.");
      }
      setLoading(false);
    } catch (error) {
      console.error("An error occurred:", error);
      generatedPrompt.textContent = `Error: ${error.message}`;
      alert(`An error occurred: ${error.message}`);
      transformedImage.style.display = "none";
      transformedImagePlaceholder.style.display = "flex";
      setLoading(false);
    }
  }

  function setLoading(isLoading) {
    generateButton.disabled = isLoading;
    uploadButton.disabled = isLoading;
    if (isLoading) {
      loader.style.display = "flex";
      transformedImage.style.display = "none";
      transformedImagePlaceholder.style.display = "none";
    } else {
      loader.style.display = "none";
    }
  }

  async function fetchFromBackend(endpoint, body) {
    const response = await fetch(`${BACKEND_URL}${endpoint}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    const data = await response.json();
    if (!response.ok) {
      throw new Error(data.error || "An unknown error occurred on the server.");
    }
    return data;
  }

  async function populateExampleGallery() {
    console.log("LOG: Attempting to populate gallery...");
    try {
      const apiUrl = `${BACKEND_URL}/images`;
      console.log(`LOG: Fetching image list from ${apiUrl}`);
      const response = await fetch(apiUrl);
      console.log("LOG: Response from /api/images:", response);

      if (!response.ok) {
        throw new Error(`Server responded with ${response.status}: ${response.statusText}`);
      } 

      const imageNames = await response.json();
      console.log("LOG: Received data from backend:", imageNames);
      
      if (!Array.isArray(imageNames)) {
        throw new Error("Backend response is not a valid array.");
      }
      
      if (imageNames.length === 0) {
        console.warn("LOG: Received empty list from backend. Gallery will be empty.");
      }

      galleryContainer.innerHTML = ""; // Clear existing

      imageNames.forEach((imageName) => {
        console.log(`LOG: Creating thumbnail element for: ${imageName}`);
        const img = document.createElement("img");
        
        // The thumbnail URL is served from the backend
        img.src = `${BACKEND_URL}/thumbnails/${imageName}`;
        img.alt = `Example image ${imageName}`;
        img.classList.add("thumbnail");
        
        // Store the full image URL in a data attribute for later
        img.dataset.fullImageUrl = `${BACKEND_URL}/images/${imageName}`;

        galleryContainer.appendChild(img);
      });
    } catch (error) {
      console.error("LOG: CRITICAL - Could not load example gallery.", error);
      galleryContainer.innerHTML =
        `<p style="color: red;">Error: Could not load images. Check browser console (F12) for details.</p>`;
    }
  }
});

<./frontend\style.css>
/* frontend/style.css (Corrected) */

:root {
    --background-color: #f8f9fa;
    --surface-color: #ffffff;
    --primary-color: #00aaff;
    --primary-hover-color: #0088cc;
    --text-primary: #212529;
    --text-secondary: #6c757d;
    --border-color: #dee2e6;
    --shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
    --border-radius: 12px;
    --font-family: 'Inter', sans-serif;
    --main-gap: 1.5rem;
}

* {
    box-sizing: border-box;
}

/* 1. Make the page fill the screen and prevent scrolling */
html, body {
    height: 100vh;
    overflow-y: auto; /* Allow scrolling for the whole page if content overflows */
}

body {
    font-family: var(--font-family);
    background-color: var(--background-color);
    color: var(--text-primary);
    margin: 0;
    padding: var(--main-gap);
    display: flex;
    flex-direction: column;
    /* Changed to column for gallery */
    align-items: center;
}

.main-container {
    width: 100%;
    max-width: 1200px;
    /* 4. Max width constraint */
    height: 100%;
    display: flex;
    flex-direction: column;
    gap: var(--main-gap);
}

.header {
    text-align: center;
    flex-shrink: 0; /* Prevents the header from shrinking */
}

.header h1 {
    font-size: 2.5rem;
    font-weight: 700;
    margin: 0 0 0.5rem 0;
    letter-spacing: -1px;
}

.header p {
    font-size: 1.1rem;
    color: var(--text-secondary);
    margin: 0;
}

.example-gallery-container {
    background-color: var(--surface-color);
    border-radius: var(--border-radius);
    padding: 1rem;
    margin-bottom: var(--main-gap);
    width: 100%;
    max-width: 1200px;
    box-shadow: var(--shadow);
    flex-shrink: 0;
}

.example-gallery-container h3 {
    text-align: center;
    margin-top: 0;
    margin-bottom: 1rem;
    font-weight: 500;
}

.gallery-thumbnails {
    display: flex;
    justify-content: flex-start; /* Align items to the left */
    gap: 1rem;
    flex-wrap: nowrap; /* CRITICAL: Force all items onto a single line */
    overflow-x: auto; /* CRITICAL: Enable horizontal scrolling */
    padding-bottom: 1rem; /* Add some space for the scrollbar */
}

/* Optional: Style the scrollbar for a cleaner look */
.gallery-thumbnails::-webkit-scrollbar {
    height: 8px;
}

.gallery-thumbnails::-webkit-scrollbar-track {
    background: #f1f3f5;
    border-radius: 10px;
}

.gallery-thumbnails::-webkit-scrollbar-thumb {
    background: #d3d3d3;
    border-radius: 10px;
}

.gallery-thumbnails::-webkit-scrollbar-thumb:hover {
    background: #b3b3b3;
}


.thumbnail {
    height: 80px;
    width: 120px;
    flex-shrink: 0; /* Prevent thumbnails from shrinking */
    object-fit: cover;
    border-radius: 8px;
    border: 2px solid transparent;
    cursor: pointer;
    transition: transform 0.2s, border-color 0.2s;
    background-color: #e9ecef;
}

.thumbnail:hover {
    transform: scale(1.05);
    border-color: var(--primary-color);
}


.content {
    flex-grow: 1;
    /* Allows this main section to fill available vertical space */
    min-height: 0;
    /* Crucial fix for flexbox children to prevent overflow */
    display: flex;
    flex-direction: column;
    gap: var(--main-gap);
    width: 100%;
}

.card {
    background-color: var(--surface-color);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    padding: 1rem;
    display: flex;
    flex-direction: column;
    box-shadow: var(--shadow);
}

.card-header {
    font-size: 1rem;
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}

.image-comparison-container {
    flex-grow: 1;
    /* Make the image area fill the space in .content */
    min-height: 0;
    /* Another crucial flexbox fix */
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--main-gap);
    /* 3. Consistent spacing between cards */
}

.image-card {
    padding: 1rem;
    min-height: 0;
}

.image-card .card-header {
    margin-bottom: 1rem;
}

/* This is the container that holds either the placeholder or the image */
.image-content-wrapper {
    flex-grow: 1;
    min-height: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    /* For loader positioning */
}

/* 2. Style images to be shown completely, not cut */
.image-card img {
    max-width: 100%;
    max-height: 100%;
    object-fit: scale-down; /* This ensures the entire image is visible */
    border-radius: 8px;
    background-color: #e9ecef;
}

.image-placeholder {
    width: 100%;
    height: 100%;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border: 2px dashed var(--border-color);
    color: var(--text-secondary);
    cursor: pointer;
    transition: background-color 0.2s, border-color 0.2s;
}

.image-placeholder:hover {
    background-color: #f1f3f5;
    border-color: var(--primary-color);
}

.image-placeholder svg {
    margin-bottom: 1rem; color: #adb5bd; transition: color 0.2s;
}
.image-placeholder:hover svg {
    color: var(--primary-color);
}

.loader-container {
    position: absolute;
    /* Positioned on top of the wrapper */
    inset: 0;
    display: none;
    /* Hidden by default */
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background-color: rgba(255, 255, 255, 0.85);
    border-radius: 8px;
}

.loader {
    width: 60px; height: 60px; border: 5px solid var(--border-color);
    border-top-color: var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 1rem;
}

@keyframes spin { to { transform: rotate(360deg); } }

.prompt-container {
    flex-shrink: 0; /* Prevent prompt from growing too large */
}

.prompt-container p {
    font-size: 1rem;
    color: var(--text-secondary);
    line-height: 1.5;
    margin: 0;
    max-height: 110px; /* Limit height to prevent layout shift */
    overflow-y: auto;
    /* Add scroll for long prompts */
    padding-right: 10px;
    /* Space for scrollbar */
}

.controls-container {
    display: flex;
    justify-content: center;
    gap: 1.5rem;
    flex-shrink: 0;
}

.button {
    background-color: var(--primary-color);
    color: #fff;
    border: none;
    padding: 0.8rem 2rem;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.2s;
    box-shadow: 0 4px 15px rgba(0, 170, 255, 0.2);
}

.button:hover:not(:disabled) {
    background-color: var(--primary-hover-color);
    transform: translateY(-2px);
}

.button:disabled {
    background-color: #ced4da;
    color: #6c757d;
    cursor: not-allowed;
    box-shadow: none;
}

@media (max-width: 900px) {
    body { padding: 1rem; --main-gap: 1rem; }
    .image-comparison-container { grid-template-columns: 1fr; }
}

<./frontend\vite.config.js>
import { defineConfig } from 'vite';

export default defineConfig({
  server: {
    // Allow requests from your specific host.
    allowedHosts: ['almere.i-am-hellguz.uk'],

    // Ensure the server is accessible externally (replaces --host flag).
    host: true,

    // Use polling for file watching to ensure hot-reloading works in Docker.
    watch: {
      usePolling: true,
    },
  },
});

<./nginx\nginx.conf>
# /nginx/nginx.conf - Reverse Proxy Configuration

server {
    listen 80;
    server_name almere.i-am-hellguz.uk localhost;

    # Increase max body size to allow for large image uploads
    client_max_body_size 20M;
    
    # Route API calls to the backend service
    location /api/ {
        proxy_pass http://backend:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Route all other calls to the frontend service
    location / {
        proxy_pass http://frontend:5173;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Required for Vite's Hot Module Replacement (HMR) to work through the proxy
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # --- CACHING FIX FOR DEVELOPMENT ---
        # The following directives prevent the browser and proxy from caching
        # frontend assets, ensuring you always see the latest version.
        expires -1;
        add_header Cache-Control 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0';
        etag off;
        proxy_no_cache 1;
        proxy_cache_bypass 1;
    }
}

